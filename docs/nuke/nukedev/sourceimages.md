# 剪辑管理与素材录入

## 剪辑管理的概念

* 剪辑时间线
* 素材层
* EDL
* 时码
* 元数据
* 版本
* 小样
* 特殊效果

## 素材与镜头的对应关系

一个镜头可能由多段素材组成，例如镜头内变速的情况，或者存在多层素材的情况，因此需要区分镜头的剪辑信息和素材的剪辑信息。

镜头的剪辑信息包括：
* 镜头长度（帧数）
* 镜头编号
* 镜头剪辑顺序
* 镜头所包含的素材

素材的剪辑信息包括：
* 素材的条号及其他元数据信息
* 素材的起始结束时码
* 素材的长度
* 素材的层名和层顺序
* 素材的时间线位置
* 素材的变速
* 畸变和缩放信息

由此可见，理想情况下，需要为素材创建不同的版本，在每个版本中记录对应的素材剪辑信息，同时为镜头也创建不同的版本，
记录下镜头的剪辑信息。如果镜头不支持创建版本，至少要记录下当前最新的剪辑信息，并指向到所包含的素材版本。
不建议把属于素材剪辑信息的内容写在镜头剪辑信息里，除非当前项目所有的镜头都对应单段素材。

## 剪辑变更

剪辑变更同样分为镜头的变更和素材的变更，但归根结底影响到的还是素材。例如一个镜头被取消制作了，或者改动了场次号、镜头号，
改动了总长度，这些都属于镜头的剪辑变更，但镜头本身是一个容器，其内部的实体是素材，上述的剪辑变更对于素材而言只是标识符的变更，
而素材本身还有更多的变更类型。

### 源文件变更
使用另一段源素材替换当前的源素材（例如一个镜头拍了多条，导演选择另外一条），这时候条号、时码都会相应发生变化，但其他信息不变。

### 时码变更
指的是素材条不变，但是起始帧结束帧的时码变掉了，这有可能会造成长度或速度的变化，也可能长度速度不变，比如选择了同一条中的另外一段

### 长度变更
指的是素材条不变，素材长度变化，这里时码可能会变也可能不变，如果时码不变，长度变化一定伴随着速度变化

### 速度变更
指的是当前素材在时间线上的变速比发生改变

### 顺序变更
指的是素材的排列顺序发生变化，这通常对应镜头的剪辑顺序变化，至于素材本身的长度速度是否发生变化仍要具体考察

### 层变更
指的是镜头中添加或删除了素材层，或者素材层的命名、叠加顺序发生变化

## 剪辑变了怎么办？

我们可以很方便地通过新建版本来记录下各类剪辑信息的变更，但是在剪辑管理中涉及到不同环节之间版本号的对应，需要特别注意。
首先，剪辑方会有自己的版本号，这通常是按日期或全片的剪辑版本号来命名的；其次，素材在录入到服务器的时候会有版本号，理论上讲，
素材的版本数量应与剪辑的版本数量一致，并能够查询到两者之间的对应关系，但是，很多情况下需要对素材做一些预处理，
比如由合成进行retime，或者合并多段素材，或者创建matte，这时候合成会按任务版本号进行输出，这里就需要跟踪任务版本号和素材版本号之间的对应关系。
下游其他组拿到素材又会按照自己的任务版本号输出自己环节的文件，因此每一环节的版本号都需要回溯到其上游版本号，直至回溯到素材版本号。
这样才能保证在素材版本更新的时候能够依次通知到下游各个组。不幸的是，几乎90%的公司都没有完善处理这件事情，更多情况下，素材更新了版本后，
是由协调人工通知下游各部门，由各制作人员手动检查自己的制作内容是否需要更新。

另外，并非剪辑变更之后就一定要重新出素材，例如剪辑长度变短的情况，那么只要在上一版的基础上减少制作范围即可。再比如镜头编号变更的情况，
素材文件本身无需更新，只要更新镜头号标识符即可。

剪辑变更的管理是一项非常庞大的工程，在做Dailies Review的时候，同样需要确保导入的下游dailies版本与素材版本匹配。

## 素材录入

素材录入指的是将DI给过来的原始素材序列帧（有时候甚至是MOV文件）按照指定的格式规范和命名规范转换输出到对应的素材文件夹的过程。

这其中涉及到以下问题：

1. DI通常没有给原始素材命名，使用的大多是摄影机自动生成的文件名，如何批量、自动地区分这些序列帧并为其重命名？
2. 如何应对变速和叠化的情况？曲线变速的素材如何录入？
3. 多次录入的时候是否应当升级版本号？

## 素材录入步骤

1. 核对DI给过来的素材和剪辑小样，按镜头剪开排列好并分轨
2. 为素材指定镜头号、层号
3. 在shotgun上为每段素材创建版本，记录素材剪辑信息
3. 把素材按照指定色彩空间和格式进行转码，按照指定镜头编号进行重命名，并导出到服务器指定的路径下
5. 在shotgun上创建镜头，上传镜头小样或缩略图，上传镜头剪辑信息
6. 在剪辑有变更的时候同步更新素材文件和shotgun记录

## Hiero API

平时的开发主要看`Hiero API Reference`中的hiero.core reference，这里面包含了hiero内置的Python对象类型及其包含的属性和功能，以下简单介绍几个常用的。
 
### TrackItem
这是最常用的一个类型，时间线上每一个片段即是一个TrackItem，TrackItem可能只包含视频也可能同时包含音频。TrackItem继承自TrackItemBase，
因此含有TrackItemBase的属性及功能。
* name() 获取名字
* metadata() 获取元数据，返回的是一个DataCollection类型的对象，可以用.dict()转换为字典，详见API文档中DataCollection的介绍
* setSource() 设置TrackItem的素材源
* setSourceIn()、setSourceOut() 设置素材源入点、出点
* setTimelineIn()、setTimelineOut() 设置TrackItem在时间线上的入点、出点
* source() 获取素材源，返回的仍是NukeStudio内部的对象，通常需要加上.mediaSource()以返回实际的文件对象
* sourceIn()、sourceOut()、timelineIn()、timelineOut()、duration() 获取素材源入点出点、时间线入点出点和时长
* copy() 使用python deep copy的方式复制一个TrackItem，不能使用简单的copy方式，否则TrackItem内部一变复制的也会跟着变
* parent() 获取所在轨道， 再加一个parent()可以获取所在序列，再加一个parent()可以获取所在项目
 
### VideoTrack
这是视频轨的类型，继承自TrackBase
* addTrackItem() 在轨道上添加一个已有的TrackItem
* createTrackItem() 创建一个新的TrackItem并添加到轨道
* createEffect() 创建一个效果并添加到指定轨道、与指定TrackItem对齐
* items() 返回轨道下所有TrackItem

### Timecode
这是NukeStudio内部的时码类型，有一些实用函数可以实现时码到帧号的转换
 
### EffectTrackItem
这是时间线上效果的类型，继承自SubTrackItem
* node() 返回其对应的Nuke节点
 
### BinItem
这是在Project Bin中的元素的类型，有一些版本管理相关的函数
* activeItem() 返回其实际的Clip或Sequence
 
hiero.core.projects()[-1]用于获取当前打开的工程。

## NukeStudio时间线工具制作

需要注意的是，往NukeStudio时间线添加右键菜单的方法与Nuke不同，需要以QMenu/QAction的形式先将菜单组织起来，
再添加到右键菜单所发出的event的menu中，然后将这一添加函数注册到NukeStudio。

Plate Ingestion工具制作的核心在于获取TrackItem上的各种信息，之后便可以用这些信息结合各种函数进行剪辑管理操作。
# Houdini 节点

## nodes节点
### 主要知识点
* 首先了解houdini的节点特性，有什么共性。
* 什么是节点
* 一样的节点，不一样的预设
* 基础节点VS复杂的节点
* 节点的选择

## 节点是什么
* houdini中的节点：类似于可视化的编程，具体的意思就是通过节点把一个或者多个功能封装起来，你不需要自己动手输入编程和考虑编程的语法和规范，而是通过节点的排列组合和链接来实现编程的效果。
* 优势：不要记住节点完整的单词，就比如，在houdini中，按tab键，输入首字母，就可以自动检索出来对应的节点，同时也不需要担心写错语法，比如括号之类的地方。
* 注意：节点是可视化编程，并不是说他没有规则，对于节点的顺序和链接的方式，都是非常重要的，这些可以理解成他的语法，也就是规则。
* 如果houdini和编程封装的类一样，如果每个节点只是负责最基本的功能，你需要连接大量的节点才能完成一笑个功能，这样非常的麻烦。这个和编程语言是一样的，基于最基本的内容衍生出了大量的库和函数，houdini也会基于基本的节点衍生出这种复合节点和不同的预设，这样就能导致houdini的节点看起来非常多，不过我们知道了他的基本原理之后，反过来进行分类和拆解，相对理解起来就容易很多。

## 一样的节点，不用的预设

在houdini中，有这样一类的节点，同一个节点，名称看起来不一样，但是这需要分两种情况：
* 1、只是预设改了，方便用户快速的选择和设置（因为有些节点的参数过多，每次都要自己调整非常麻烦）

* 2、vop和wrangle节点
  例如：

  ![houdini_sop1](http://artiststd.xyz/img/houdini_sop1.jpg)
  图标都是一样的，其实他们都是一个节点，只是预设run over的值不一样。

  ![houdini_sop2](http://artiststd.xyz/img/houdini_sop2.jpg)
修改这几个值，就对应了这几个节点。在wrangle1节点上也是同理的。
* 3、如何判定是同一个节点
1.看图标是不是一样的。2.看属性面板节点类型的名称。
*  4、foreach loop节点
第二种情况：
* 1、旧版本的节点更新、名字保留，这样的做法的目的是为了让旧版本的用户能够通过之前的节点名字找到对应的节点。
*  group/group create
*  polycap/polyfill
*  duplicate/copy and transform

###  基础节点VS复杂的节点
* null/box

* blast/split

* 如何判定？
  在节点上右键，可以看到allow editing of contents，就是复合节点。

* digital asset 自己封装节点
  选择需要封装的节点，点击下图所示位置：
![houdini_sop3](http://artiststd.xyz/img/houdini_sop3.jpg)

### 基础节点VS复杂的节点
节点的新旧都是相对而言的，每次的版本更新都会产生新的节点和淘汰一部分的节点，但是houdini有一个很明显的分水岭，也就是开始普及了vex语言，以这个标准来作为分水岭的好处：
* 1、旧的节点是支持hscript的，新的节点支持vex，vex的性能运算是更快的，相同的功能，新旧节点应该选择的是支持vex的新节点。
* 2、新的节点不支持hsript，比如$CR的写法。
* 3、新的节点更加简洁和通用，可以类比的去学习和运用，甚至是可以使用wrangle节点通过基本的函数实现相同的功能。

区分新旧节点：
* 1、直接看后缀是否有_old
* 2、如果节点后面带上了_old的后缀，这个节点肯定是旧节点，而且这种节点说明houdini很快就淘汰他了。
* point_old
* vertex_old
* extrude_old
* 4、看是否支持VEX语言
* 这套看起来是最简单可行的措施，但是这是本末倒置的方法，是因为新的节点是由vex构成才支持vex，而不是因为支持vex所以是新节点，所以我们的判定新旧节点的目的之一就是为了知道它是否使用了vex语言，而不是因为知道了他能支持vex语言所以判断他是新节点。
* rand(@ptnum)不是Vex语言。
* houdini的体系中，我们使用的语言不是以语言符号设别的，而是以节点自身来判定的。

4 、看节点的构成
* 这个方法是最靠靠谱的，也就是一般新的vex节点都是由vex内核构成的，大部分都是复合节点，内部由vop等节点构成，还有少量的是直接用vex编写的。
* wrangle节点
* group exprssion节点类型节点。
* mountatin节点等等。

?> 这些节点我们双击进入，就可以看到它里面是用vex代码编写的。其他类型的是无法进入的。

## 节点的选择

* 1、新旧节点的选择时，首先选择用新的节点(vex)
* 2、如果为了实现单一的功能，选择简单功能的节点。比如：normal VS facet
* 3、即使一个节点可以同时实现多种复杂的功能，大部分情况下尽量简单拆分，wrangle节点除外。

## 总结

!> 对比了我们之前学习houdini的方法，为什么会觉得难，为什么会记不住很多节点?,因为没有从一个整体和有逻辑的体系来一层层的解剖开，和他们之间的关系也不清晰。非常的零散，所以很容易忘记，导致后续的不断重复的学习和混乱的逻辑。

> 所以我们需要把看似庞大的节点进行解剖，其实发现节点的重复使用是非常之高的，无论是预制的还是复合节点，我们需要的就是找到他们之间的关系，和内在的逻辑，对比的来学习，把各个独立的模块关联起来，这样我们从本质上理解这些节点的区别，多去尝试不同的效果。总结最优方案。这样有利用后续的学习和提高，打下坚实的基础。利用好自己的时间，在这些问题上，多反思。重构自己的知识体系，才能更加全面的掌握比较完善的知识。

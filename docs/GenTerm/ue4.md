# 虚幻引擎4常用术语

?> 本页面的目的是介绍当应用 虚幻引擎 4 时遇到的常用术语。比如，如果您发现自己会问像 "什么是 Actor"、"什么是 组件"、"什么是 Pawn"这样的问题，那么本页面便突出介绍了并提供了关于这些类型问题的描述。一旦您理解了每个术语的意思，下面的链接提供了更多文档及如何使用它们的指南。


## Project 项目

项目（Project） 是一个自成体系的单元，保存所有组成单独游戏的所有内容和代码，并与您硬盘上的一组目录相一致。例如，内容浏览器（Content Browser） 的层级结构树下的图片包含了可在您磁盘上项目文件夹中找到的相同目录结构。单击图像显示完整视图。

尽管一个项目会经常被与其关联的.uproject`文件所引用，但它们是两个互相并存的独立文件。.uproject`是一个用于创建、打开或保存文件的参考文件，而项目则包含与其关联的所有文件和文件夹。

您可以创建任意数量的不同项目，所有这些项目都可以并行维护和开发。引擎（和编辑器）可以在它们之间前轻松切换，从而允许您同时处理多个游戏或在主游戏项目之外还拥有多个测试项目。

要了解更多信息，请参阅： 使用虚幻项目

## Object 对象

在虚幻引擎中，最基础的构建单元叫做 Object，它包含了很多游戏资源必需的 幕后 功能。虚幻引擎4中几乎所有的东西都是继承自Object（或从中获取部分功能）。在C++中，UObject 是所有Object的基类，实现了诸如垃圾回收、开放变量给编辑器的元数据（UProperty），以及存盘和读盘时的序列化功能。

要了解更多信息，请参阅： 虚幻项目和游戏性 , 游戏逻辑编程


## Class 类

类（Class） 用于定义在创建虚幻引擎游戏中使用的特定Actor或对象的行为和属性。类具有层级性，这意味着某个类从其父类（衍生或派生出该类的类）获得信息，然后再将信息传递给子项。类可用C++代码或蓝图创建。

要了解更多信息，请参阅： 蓝图类 , 游戏性类 , 类创建基础知识

## Actors

可放入关卡中的对象都是 Actor。Actor是支持三维转换（如平移、旋转和缩放）的泛型类。可通过游戏进程代码（C++或蓝图）创建（生成）及销毁Actor。在C++中，AActor是所有Actor的基本类。

Actor分为数种类型，示例包括：StaticMeshActor、CameraActor和PlayerStartActor。

要了解更多信息，请参阅： Actor和几何体


## Component 组件

组件（Component） 是可添加到Actor的一项功能。组件不可独立存在，但在将其添加到Actor后，该Actor便可以访问并可以使用该组件所提供的功能。

例如，聚光灯组件（Spot Light Component）将允许您的Actor像聚光灯一样发光，旋转移动组件（Rotating Movement Component）将使您的Actor四处旋转，音频组件（Audio Component）将使您的Actor能够播放声音。

要了解更多信息，请参阅： 组件 , 组件窗口 , 代码中的组件 。

## Pawn 人形体

Pawn 是Actor的一个子类，充当游戏中的化身或假面，例如游戏中的角色。Pawn可以由玩家或游戏AI以非玩家角色（NPC）的形式控制。

当Pawn被人类玩家或AI玩家控制时，它被视为 已被支配。相反，当Pawn未被人类玩家或AI玩家控制时，它被视为_未被支配_。

要了解更多信息，请参阅： Pawn , 支配 Pawn

## Character 角色

角色（Character） 是Pawn Actor的子类，旨在用作玩家角色。角色子类包括碰撞设置、双足运动的输入绑定，以及由玩家控制的运动附加代码。

要了解更多信息，请参阅： 角色 , 角色设置 , 指南 - 角色运动


## PlayerController 玩家控制器

玩家控制器（PlayerController） 类用于在游戏中获取玩家输入并将其转换为交互，每个游戏中至少有一个玩家控制器。玩家控制器通常拥有一个Pawn或角色作为游戏中玩家的代表。

玩家控制器也是多人游戏的主要网络交互点。在多人游戏中，服务器为游戏中的每个玩家提供一个玩家控制器实例，因为它必须能够对每个玩家进行网络函数调用。每个客户端只有与其玩家相对应的玩家控制器，并且只能使用其玩家控制器与服务器通信。

要了解更多信息，请参阅： PlayerController(玩家控制器)


## AIController 人工智能控制器

就像玩家控制器拥有一个兵卒作为游戏中玩家的代表一样，AI控制器 也拥有一个兵卒来代表游戏中的非玩家角色（NPC）。默认情况下，兵卒和角色最终将使用基本AI控制器，除非它们专门被玩家控制器拥有或者被告知不要为它们自己创建一个AI控制器。

要了解更多信息，请参阅： AIController

## Brush 画刷

笔刷（Brush） 是一种Actor，用于描述置于关卡中的三维体积，以便对关卡几何体（称为BSP）和游戏进程体积进行定义。通常您将使用BSP笔刷制作您要进行游戏进程测试的关卡或屏蔽该关卡。

另一方面，根据附加在它们上的效果，体积具有多种用途，例如：阻塞体积（Blocking Volume）（它们是不可见的，用于阻止Actor穿过它们）、伤害产生体积（Pain Causing Volume）（随着时间的推移，会对与其重叠的Actor造成伤害）或触发器体积（Trigger Volume）（用作在Actor进入或退出它们时引发事件的一种方式）。

要了解更多信息，请参阅： 几何体笔刷Actor , 几何体编辑范例

## Level 关卡

level （关卡）是用户定义的游戏区域。 我们主要通过放置、变换及编辑Actor的属性来创建、查看及修改关卡。 在虚幻编辑器中，每个关卡都被保存为单独的.umap文件，所以它们有时也被称为"地图"。

关于更多信息，请参阅: 关卡 , 关卡编辑器 , 关卡设计内容示例


## World 世界

世界场景（World） 中包含载入的关卡列表。它可处理关卡流送和动态Actor的生成（创建）。

虽然没有必要与世界场景进行直接交互，但直接交互确实有助于在游戏结构中提供一个特定的参考点（即直接提及世界场景意味着您不是在谈论关卡、地图或游戏）。

要了解更多信息，请参阅： 世界场景构成用户指南


## GameMode 游戏模式

游戏模式（GameMode） 类负责设置正在执行的游戏的规则。规则可包括玩家如何加入游戏、是否可暂停游戏、关卡过渡，以及任何特定的游戏行为（例如获胜条件）。

您可以在 项目设置（Project Settings） 中设置默认的游戏模式，但可以逐关卡地对其进行覆盖。无论您选择如何实施游戏模式，每个关卡始终只有一个游戏模式。在多人游戏中，游戏模式只存在于服务器上，规则将被复制（发送）到每个联网的客户端。

关于更多信息，请参阅: Game Mode 和 Game State , 在蓝图中设置游戏模式

## GameState 游戏状态

游戏状态（GameState） 包含要复制到游戏中的每个客户端的信息，简而言之，它表示每个联网玩家的"游戏状态"。

它通常包含有关游戏分数、比赛是否已开始和基于世界场景玩家人数要生成的AI数量的信息，以及其他特定于游戏的信息。

对于多人游戏，每个玩家的机器上都有一个游戏状态实例，而服务器的实例为权威实例（或客户端从其获得更新信息的实例）。

关于更多信息，请参阅: GameState



## PlayerState 玩家状态

玩家状态（PlayerState） 是游戏玩家的状态，例如人类玩家或模拟玩家的机器人。作为游戏世界场景的一部分而存在的非玩家AI将不会拥有玩家状态。

在玩家状态中适当的示例数据包括玩家姓名或得分、当前等级或生命值，或当前是否在抢旗游戏中携带旗帜。

对于多人游戏，所有玩家的玩家状态存在于所有机器上（与玩家控制器不同），并且可以将数据从服务器复制到客户端以保持同步。

关于更多信息，请参阅: Gameplay框架快速参考